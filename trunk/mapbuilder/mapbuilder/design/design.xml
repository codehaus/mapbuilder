<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article id="design">
  <title>Community Map Builder Software Design Description</title>

  <abstract>
    <para>This document describes the design of Community Map Builder.</para>
  </abstract>

  <section id="systemoverview">
    <title>System Overview</title>

    <para>The Community Map Builder (CMB) contains:</para>

    <orderedlist>
      <listitem>
        <para>An open source framework for communities to collectively edit
        geographic data.</para>
      </listitem>

      <listitem>
        <para>Javascript and XSL modular libraries which can be integrated to
        build geographic widgets. The widgets implement clients to Open GIS
        Consortium (OGC) services.</para>
      </listitem>

      <listitem>
        <para>Specific OGC clients which have been built using CMB
        widgets.</para>
      </listitem>
    </orderedlist>
  </section>

  <section id="framework">
    <title>CMB framework</title>

    <para>The CMB framework is designed for collaborative, open sharing of
    place-based information. It builds upon components that conform to Open
    GIS's international Standards for geospatial software development. The aim
    is to create business logic components using Open Source,
    OpenGIS-compliant components for this effort. Map serving uses the
    OpenGIS<emphasis> Web Map Server</emphasis>-compliant software, <ulink
    url="http://mapserver.gis.umn.edu">Mapserver.</ulink> Spatial feature
    updating uses the OpenGIS <emphasis>Web Feature
    Server</emphasis>-compliant software <ulink
    url="http://geoserver.sourceforge.net">Geoserver</ulink>, which relies
    upon Postgres and the PostGIS component as its spatial database. CMB also
    uses Postgres as a normal database to store community-contributed text and
    photographs.</para>

    <para>Community Map Builder is more than just a collection of
    technologies. It is a collection of Web pages, server applications and
    database schema, along with implementation recommendations.<!--Good summary.  It is probably worth coming back and polishing this section and using for
all the CMB docs.
I think the CMB should also provide logic for community editing of shared data
(in a similar fashion to http://slashdot.org).  This would be part of a future phase.--></para>

    <figure>
      <title>High Level Design</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/context0.png" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>CMB Libraries</title>

    <para>CMB libraries contain components that can be used to build clients
    to OGC services.</para>

    <section id="designdecisions">
      <title>Design Decisions for CMB Libraries</title>

      <section id="designdrivers">
        <title>Design Drivers</title>

        <para>The goals of the libraries are to provide the following:</para>

        <variablelist>
          <varlistentry>
            <term>Client is a Web Browser</term>

            <listitem>
              <para>Mapbuilder Clients should be easy for users to run. Users
              should not have to download and install new software. Instead
              all CMB clients should run inside the commonly used web
              browsers. In particular, recent Internet Explorer and Mozilla
              browsers.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Minimal Server Side Functionality</term>

            <listitem>
              <para>CMB should keep deployment requirements to a minimum in
              order to maximise the user base. Hence:</para>

              <orderedlist>
                <listitem>
                  <para>Where possible, clients should not require server side
                  scripts.</para>
                </listitem>

                <listitem>
                  <para>If Server Side scripts are used, then Unix Shell
                  Scripts, Perl, or PHP should be used in preference to Java,
                  C or C++ in order to target the tools usually provided by
                  ISPs.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Easy to incorporate libraries into a web page</term>

            <listitem>
              <para>Mapbuilder widgets are to be incorporated into HTML web
              pages. Incorporating widgets should be kept simple so that
              someone with basic HTML and Javascript knowledge can build a
              Mapbuilder Web Page.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Keep bandwidth to a minimum</term>

            <listitem>
              <para>All client functionality needs to be downloaded, so it is
              important to keep it to a minimum. Files that are downloaded
              should also be static which means that browsers will cache them
              locally. (CGI scripts generally do not provide images that are
              cached).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Use Javascript/XML/XSL</term>

            <listitem>
              <para>Mapbuilder stores state data internally in XML files.
              Converting XML to HTML is done using XSL. XSL has the advantage
              that it can be used both in the client and server.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Modular Design</term>

            <listitem>
              <para>A modular design has many benefits.</para>

              <orderedlist>
                <listitem>
                  <para>A client need only include the module it requires,
                  hence reducing the size of the client.</para>
                </listitem>

                <listitem>
                  <para>A modular design is easier to understand, maitain and
                  extend.</para>
                </listitem>

                <listitem>
                  <para>It is easier to break development up between multiple
                  developers.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Modular Design</term>

            <listitem>
              <para>A modular design has many benefits.</para>

              <orderedlist>
                <listitem>
                  <para>A client need only include the module it requires,
                  hence reducing the size of the client.</para>
                </listitem>

                <listitem>
                  <para>A modular design is easier to understand and
                  maintain.</para>
                </listitem>

                <listitem>
                  <para>Extra functionality can be easily added and
                  removed.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Attract Developers</term>

            <listitem>
              <para>Hopefully potential developers will extend this project in
              preference to creating their own. Things that should help
              attract developers include:</para>

              <itemizedlist>
                <listitem>
                  <para>Keep the design simple, modular and easy to
                  understand.</para>
                </listitem>

                <listitem>
                  <para>Provide design and user documentation.</para>
                </listitem>

                <listitem>
                  <para>Provide discussion forums.</para>
                </listitem>

                <listitem>
                  <para>Provide stable releases which are easy to install and
                  evaluate.</para>
                </listitem>

                <listitem>
                  <para>Provide demos that potential users and developers and
                  try.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="mvc">
        <title>Model View Controller</title>

        <para>Mapbuilder uses the Model View Controller (MVC) design
        pattern.</para>

        <section id="mvcoverview">
          <title>MVC Overview</title>

          <figure>
            <title>Model View Controller</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/mvc.gif" />
              </imageobject>
            </mediaobject>
          </figure>

          <para>The MVC pattern forces one to think of an application in terms
          of three modules:</para>

          <variablelist>
            <varlistentry>
              <term>Model</term>

              <listitem>
                <para>This maintains the state and data that the application
                represents. When changes occur in the model, it sends update
                events to all of its views. <filename>Context</filename> is
                the Model in the Mapbuilder application and stores Layers,
                Bounding Box etc.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>View</term>

              <listitem>
                <para>The user interface which displays information about the
                model to the user. Views displaying dynamic data need to
                register for StateChange events from the Model.
                <filename>Legend</filename>, <filename>MapPane</filename>, etc
                are all Mapbuilder Views that get update events when
                <filename>Context</filename> changes.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Controller</term>

              <listitem>
                <para>The user interface presented to the user to manipulate
                the application (ie keyboard and mouse input).
                <filename>ZoomTool</filename>, <filename>PanTool</filename>,
                <filename>SelectFeature</filename> are all Mapbuilder
                Controllers which update <filename>Context</filename>.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>Some components can act as both a View and Controller. For
          example, a <filename>LocatorMap</filename> may allow users to draw a
          select box to change the BoundingBox. Also, when the BoundingBox in
          Context changes, the LocatorMap will draw a new Box over it's
          basemap.</para>

          <para>There is a lot of literature describing the MVC Design
          Pattern. Here is <ulink
          url="http://www.cs.indiana.edu/~cbaray/projects/mvc.html">one</ulink>.</para>
        </section>

        <section id="mvcbenefits">
          <title>MVC benefits</title>

          <para>The benefits of using the MVC design pattern include:</para>

          <variablelist>
            <varlistentry>
              <term>Modularity</term>

              <listitem>
                <para>Views and Tools can be added or removed without
                effecting the rest of the application. Tools do not have any
                dependencies on Views and visa-versa which makes Tools and
                Views simpler.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Multiple Views</term>

              <listitem>
                <para>Views can display the same data in different ways. For
                example, a Locater Map and Main Map both display the
                BoundingBox in different ways.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Parallel Development</term>

              <listitem>
                <para>Once the interfaces have been defined, components can be
                developed in parallel.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>

      <section id="events">
        <title>Events</title>

        <para>Mapbuilder's Model-View-Controller design requires events. While
        Javascript provides standard events for some GUI events, it's support
        for custom events is limited in recent browsers and not provided in
        older browsers. Consequency, Mapbuilder components use their own event
        system.</para>

        <para>Here mapbuilder events by example, using BoundingBoxEvent which
        is sent from Context to MapPane when the BoundingBox changes.</para>

        <variablelist>
          <varlistentry>
            <term>Store list of listeners</term>

            <listitem>
              <para>Context.js stores an array of listeners to call when
              context changes.</para>

              <programlisting>/** Functions to call when the boundingBox changes. */
this.boundingBoxChangeListeners=new Array();
</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>add&lt;Event&gt;Listener()</term>

            <listitem>
              <para>Context.js needs a procedure for registering
              Listeners.</para>

              <programlisting>/**
 * Add a Listener for boundingBox change.
 * @param listener The function to call when the boundingBox changes.
 * @param target The object which owns the listener function.
 */
this.addBoundingBoxChangeListener=function(listener,target) {
  this.boundingBoxChangeListeners[this.boundingBoxChangeListeners.length]=
    new Array(listener,target);
}
</programlisting>

              <para>Note: the target object which owns the listener function
              needs to be stored. In javascript, when the listener function is
              called it does not have a reference back to the object which
              owns the function.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>call Listeners</term>

            <listitem>
              <para>When the boundingBox changes in Context.js, call all
              listeners.</para>

              <programlisting>/**
 * Set the BoundingBox and notify intererested widgets that BoundingBox
 * has changed.
 * @param boundingBox array in form (xmin, ymin, xmax, ymax).
 */
this.setBoundingBox=function(boundingBox) {
  // Set BoundingBox in context
  // ...

  // Call all listener(target) functions
  for (var i=0; i&lt;this.boundingBoxChangeListeners.length; i++) {
    this.boundingBoxChangeListeners[i][0](
      this.boundingBoxChangeListeners[i][1]);
  }
}
</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Listener function</term>

            <listitem>
              <para>MapPane.js defines a function to call when BoundingBox
              changes. The function needs to register with Context.js.</para>

              <programlisting>/**
 * Called when the context's boundingBox attribute changes.
 * @param target This object.
 */
this.boundingBoxChangeListener=function(target){
  target.paint();
}

// Register this listener with context.
this.context.addBoundingBoxChangeListener(this.boundingBoxChangeListener,this);
</programlisting>

              <para>Note: The listener function requires this object to be
              passed in as a parameter. In javascript, when the listener
              function is called it does not have a reference back to the
              object which owns the function.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section>
      <title id="library">CMB Library Components</title>

      <figure>
        <title>CMB Library Components</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/context1.jpg" />
          </imageobject>
        </mediaobject>
      </figure>

      <section id="mainpage">
        <title>MainPage</title>

        <para>The Main Web Page uses HTML to layout the required widgets. It
        includes the required libraries, creates the required components, then
        calls the &lt;component&gt;.paint() methods.</para>

        <para>This should be the only page Portal Developers need to modify in
        order to build a Mapbuilder portal.</para>

        <para>The requirements for building the page need to be kept simple so
        that HTML developers with minimal javascript knowledge can create
        it.</para>

        <para>For details on how to build a Main Page, refer to the Users
        Guide.</para>
      </section>

      <section>
        <title>Model</title>

        <para>The model contains components which store CMB state. It is the
        Model in the Model-View-Controller design pattern.</para>

        <figure>
          <title>Model Component</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/model.jpg" />
            </imageobject>
          </mediaobject>
        </figure>

        <section id="context">
          <title>Context</title>

          <para>The context object stores geographic state, like Layers,
          Bounding Box, etc.</para>

          <para>Context realises and extends the Web Map Context (WMC)
          specification as defined by the OGC. Extensions include:</para>

          <itemizedlist>
            <listitem>
              <para>A Layer Id, required to link to the DHTML layer Id.</para>
            </listitem>

            <listitem>
              <para>A selected tag for each layer.</para>
            </listitem>

            <listitem>
              <para>Extract of a WFS Query, required to show WFS
              Layers.</para>
            </listitem>
          </itemizedlist>

          <para>Widgets which render Context information need to call
          context.add&lt;Param&gt;Listener(). Context will then call these
          widgets whenever the param changes.</para>

          <para>There are many WMC parameters that the Context needs to update
          and in a normal compiled language a get/setParam function would be
          written for each parameter. However this application is written is
          client side javascript and Context is going to be used in
          light-weight applications which require minimal image size.
          Consequently only the commonly used get/setParam functions will be
          stored in Context. Applications that require detailed access of
          Context data (like a Web Map Context Builder) will need to call
          get/setContext() to rebuild and replace the entire WebMapContext
          data.</para>
        </section>
      </section>

      <section>
        <title>Widget</title>

        <para>Widgets are the components that you can see on a MapBuilder web
        page, like a MapPane, Legend, or PanRose. A widget contains a
        javascript function which knows how to paint itself and sometimes uses
        XSL to render the Context XML.</para>

        <section id="mappane">
          <title>MapPane</title>

          <para>MapPane uses XSL to render Map Layers from Context as DHTML
          Layers.</para>

          <figure>
            <title>MapPane Component</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/mappane.jpg" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section id="legend">
          <title>Legend</title>

          <para>Legend uses XSL to render a legend based on the Context. Some
          context information, like LayerVisiblity can be changed through the
          Legend widget.</para>

          <figure>
            <title>Legend Component</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/legend.jpg" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section>
          <title>Tool</title>

          <para>A Widget Tool contains button(s) that a user can click, like a
          PanLeft button or a ZoomPanel. The Tools contain logic to update
          Context when they have been pressed. In the Model-View-Controller
          design pattern, these Tools are both a View and a Controller.</para>
        </section>

        <section id="addfeature">
          <title>AddFeature</title>

          <figure>
            <title>Web pages and processes used to add features to a
            WFS</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/addfeature.png" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title>GmlSchemaToForm</title>

            <para>This is ...</para>

            <para>In order to simplify initial versions of the GmlSchemaToForm
            XSL transformation, there are restrictions on the DescribeFeature
            schema that can be returned.</para>
          </section>
        </section>
      </section>
    </section>
  </section>
</article>