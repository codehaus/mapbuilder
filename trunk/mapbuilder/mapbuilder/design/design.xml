<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article id="design">
  <title>Community Map Builder Software Design Description</title>

  <abstract>
    <para>This document describes the design of Community Map Builder.</para>
  </abstract>

  <section id="systemoverview">
    <title>System Overview</title>

    <para>The Community Map Builder (CMB) contains:</para>

    <orderedlist>
      <listitem>
        <para>An open source framework for communities to collectively edit
        geographic data.</para>
      </listitem>

      <listitem>
        <para>Javascript and XSL modular libraries which can be integrated to
        build geographic widgets. The widgets impliment clients to Open GIS
        Consortium (OGC) services.</para>
      </listitem>

      <listitem>
        <para>Specific OGC clients which have been built using CMB
        widgets.</para>
      </listitem>
    </orderedlist>
  </section>

  <section id="framework">
    <title>CMB framework</title>

    <para>The CMB framework is designed for collaborative, open sharing of
    place-based information. It builds upon components that conform to Open
    GIS's international Standards for geospatial software development. The aim
    is to create business logic components using Open Source,
    OpenGIS-compliant components for this effort. Map serving uses the
    OpenGIS<emphasis> Web Map Server</emphasis>-compliant software, <ulink
    url="http://mapserver.gis.umn.edu">Mapserver.</ulink> Spatial feature
    updating uses the OpenGIS <emphasis>Web Feature
    Server</emphasis>-compliant software <ulink
    url="http://geoserver.sourceforge.net">Geoserver</ulink>, which relies
    upon Postgres and the PostGIS component as its spatial database. CMB also
    uses Postgres as a normal database to store community-contributed text and
    photographs.</para>

    <para>Community Map Builder is more than just a collection of
    technologies. It is a collection of Web pages, server applications and
    database schema, along with implementation recommendations.<!--Good summary.  It is probably worth coming back and polishing this section and using for
all the CMB docs.
I think the CMB should also provide logic for community editing of shared data
(in a similar fasion to http://slashdot.org).  This would be part of a future phase.--></para>

    <figure>
      <title>High Level Design</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/context0.png" />
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>CMB Libraries</title>

    <para>CMB libraries contain components that can be used to build clients
    to OGC services.</para>

    <section id="designdecisions">
      <title>Design Decisions for CMB Libraries</title>

      <section id="designdrivers">
        <title>Design Drivers</title>

        <para>The goals of the libaries are to provide the following:</para>

        <variablelist>
          <varlistentry>
            <term>Client is a Web Browser</term>

            <listitem>
              <para>Mapbuilder Clients should be easy for users to run. Users
              should not have to download and install new software. Instead
              all CMB clients should run inside the commonly used web
              browsers. In particular, recent Internet Explorer and Mozilla
              browsers.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Minimal Server Side Functionality</term>

            <listitem>
              <para>CMB should keep deployment requirements to a minimum in
              order to maximise the user base. Hence:</para>

              <orderedlist>
                <listitem>
                  <para>Where possible, clients should not require server side
                  scripts.</para>
                </listitem>

                <listitem>
                  <para>If Server Side scripts are used, then Unix Shell
                  Scripts, Perl, or PHP should be used in preference to Java,
                  C or C++ in order to target the tools usually provided by
                  ISPs.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Keep bandwidth to a minimum</term>

            <listitem>
              <para>All client functionality needs to be downloaded, so it is
              important to keep it to a minimum. Files that are downloaded
              should also be static which means that browsers will cache them
              locally. (CGI scripts generally do not provide images that are
              cached).</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Modular Design</term>

            <listitem>
              <para>A modular design has many benefits.</para>

              <orderedlist>
                <listitem>
                  <para>A client need only include the module it requires,
                  hence reducing the size of the client.</para>
                </listitem>

                <listitem>
                  <para>A modular design is easier to understand and
                  maitain.</para>
                </listitem>

                <listitem>
                  <para>Extra functionality can be easilly added and
                  removed.</para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Use Javascript/XML/XSL</term>

            <listitem>
              <para>Mapbuilder stores state data interally in XML files.
              Converting XML to HTML is done using XSL. XSL has the advantage
              that it can be used both in the client and server.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="mvc">
        <title>Model View Controller</title>

        <para>Mapbuilder uses the Model View Controller (MVC) design
        pattern.</para>
      </section>

      <section id="mvcoverview">
        <title>MVC Overview</title>

        <figure>
          <title>Model View Controller</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/mvc.gif" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>The MVC pattern forces one to think of an application in terms
        of three modules:</para>

        <variablelist>
          <varlistentry>
            <term>Model</term>

            <listitem>
              <para>This maintains the state and data that the application
              represents. When changes occur in the model, it sends update
              events to all of its views. <filename>Context</filename> is the
              Model in the Mapbuilder application and stores Layers, Bounding
              Box etc.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>View</term>

            <listitem>
              <para>The user interface which displays information about the
              model to the user. Views displaying dynamic data need to
              register for StateChange events from the Model.
              <filename>Legend</filename>, <filename>MapPane</filename>, etc
              are all Mapbuilder Views that get update events when
              <filename>Context</filename> changes.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Controller</term>

            <listitem>
              <para>The user interface presented to the user to manipulate the
              application (ie keyboard and mouse input).
              <filename>ZoomTool</filename>, <filename>PanTool</filename>,
              <filename>SelectFeature</filename> are all Mapbuilder
              Controllers which update <filename>Context</filename>.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Some components can act as both a View and Controller. For
        example, a <filename>LocatorMap</filename> may allow users to draw a
        select box to change the BoundingBox. Also, when the BoundingBox in
        Context changes, the LocatorMap will draw a new Box over it's
        basemap.</para>

        <para>There is a lot of literature describing the MVC Design Pattern.
        Here is <ulink
        url="http://www.cs.indiana.edu/~cbaray/projects/mvc.html">one</ulink>.</para>
      </section>

      <section id="mvcbenefits">
        <title>MVC benefits</title>

        <para>The benefits of using the MVC design pattern include:</para>

        <variablelist>
          <varlistentry>
            <term>Modularity</term>

            <listitem>
              <para>Views and Tools can be added or removed without effecting
              the rest of the application. Tools do not have any dependancies
              on Views and visa-versa which makes Tools and Views
              simpler.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Multiple Views</term>

            <listitem>
              <para>Views can display the same data in different ways. For
              example, a Locator Map and Main Map both display the BoundingBox
              in different ways.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Parallel Development</term>

            <listitem>
              <para>Once the interfaces have been defined, components can be
              developed in parallel.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section>
      <title id="library">CMB Library Components</title>

      <figure>
        <title>CMB Library Components</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sf_mapbuilder.png" />
          </imageobject>
        </mediaobject>
      </figure>

      <section id="mainpage">
        <title>MainPage</title>

        <para>A CMB Client page is simple. It includes the required libraries,
        creates the required components, then calls the
        &lt;component&gt;.paint() method.</para>

        <para>TBD: Note: The following code has chaged a bit.</para>

        <example>
          <title>Simple WMS Client using CMB libraries</title>

          <programlisting>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;WMS Client&lt;/title&gt;
    &lt;!-- Mapbuilder libraries --&gt;
    &lt;script type="text/javascript" src="../util/sarissa/sarissa.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="../widget/context/Context.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="../widget/mappane/MapPane.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="../widget/legend/Legend.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="../widget/util/Util.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Web Map Server Client&lt;/h1&gt;

    &lt;script&gt;
      // Base Mapbuilder library directory
      baseDir="../widget";

      // Load a Web Map Context document as defined by:
      // http://www.opengis.org/docs/03-036r2.pdf
      context=new Context("Wmc1.cml");

      // Create and render a MapPane
      mapPane=new MapPane(context,baseDir,null);
      mapPane.paint();

      // Create and render a Legend
      legend=new Legend(context,baseDir,null);
      legend.paint();
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>
        </example>
      </section>

      <section id="context">
        <title>Context</title>

        <para>The context object stores geographic state, like Layers,
        Bounding Box, etc.</para>

        <figure>
          <title>Context Component</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/sf_mapbuilder_context.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>In the Model-View-Controller design pattern, Context is the
        Model.</para>

        <para>Context realises and extends the Web Map Context (WMC)
        specification as defined by the OGC. Extensions include:</para>

        <itemizedlist>
          <listitem>
            <para>A Layer Id, required to link to the DHTML layer Id.</para>
          </listitem>

          <listitem>
            <para>A selected tag for each layer.</para>
          </listitem>

          <listitem>
            <para>Extract of a WFS Query, required to show WFS Layers.</para>
          </listitem>
        </itemizedlist>

        <para>Widgets which render Context information need to call
        context.add&lt;Param&gt;Listener(). Context will then call these
        widgets whenever the param changes.</para>

        <para>There are many WMC parameters that the Context needs to update
        and in a normal compiled language a get/setParam function would be
        written for each parameter. However this application is written is
        client side javascript and Context is going to be used in light-weight
        applications which require minimal image size. Consequently only the
        commonly used get/setParam functions will be stored in Context.
        Applications that require detailed access of Context data (like a Web
        Map Context Builder) will need to call get/setContext() to rebuild and
        replace the entire WebMapContext data.</para>
      </section>

      <section id="tool">
        <title>Tool</title>

        <para>Tool provides objects for processing mouse events on behalf of
        MapPane.</para>
      </section>

      <section>
        <title>Widget</title>

        <section id="mappane">
          <title>MapPane</title>

          <para>MapPane renders Geographic Layers from Context as DHTML
          Layers, and changes these Layers inline with Context changes.</para>

          <figure>
            <title>MapPane Component</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/sf_mapbuilder_mappane.png" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section id="legend">
          <title>Legend</title>

          <para>Legend renders a legend based on the Context. Some context
          information can be changed through the Legend widget.</para>

          <figure>
            <title>Legend Component</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/sf_mapbuilder_legend.png" />
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section id="addfeature">
          <title>AddFeature</title>

          <figure>
            <title>Web pages and processes used to add features to a
            WFS</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="images/addfeature.png" />
              </imageobject>
            </mediaobject>
          </figure>

          <section>
            <title>GmlSchemaToForm</title>

            <para>This is ...</para>

            <para>In order to simplify initial versions of the GmlSchemaToForm
            XSL transformation, there are are restrictions on the
            DescribeFeature schema that can be returned.</para>
          </section>
        </section>
      </section>
    </section>
  </section>
</article>